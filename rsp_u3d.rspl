include "rsp.inc"

// some dummy defines to make it work without libdragon
#define RSPQ_BeginOverlayHeader ;
#define RSPQ_EndOverlayHeader ;
#define RSPQ_BeginSavedState ;
#define RSPQ_EndSavedState ;


state 
{
  u8 SHIFT_DATA[8];
  u32 VERTEX_ADDR;
  u32 RDPQ_CURRENT;
  alignas(8) u16 MATRIX[3][4]; // fractional matrix for scaling + rotation
  alignas(16) u8 RSPQ_DMEM_BUFFER[1024];

  // @TODO:
  u32 TRI_COMMAND;
  u32 RDPQ_OTHER_MODES;

  u16 RDPQ_TRI_BUFF_OFFSET;

  u8 VERT_BUFF[1024];
  vec16 RSPQ_SCRATCH_MEM;
}

function RDPQ_Triangle_Send_Async();

// DMA from RDRAM into DMEM
macro dmaInAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_read(size);
}

// DMA from DMEM into RDRAM
macro dmaOutAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_write(size);
}

macro dmaAwait()
{
  loop { 
    RA = get_dma_busy();
  } while(RA != 0)
}

#define RDP_POS_MASK 0b1111'1111'1111

macro encodeRectPos(u32 outA, u32 outB, vec16 pos)
{
  outA = pos.y;
  outA &= RDP_POS_MASK;
  u32 tmp = pos.x;
  tmp <<= 12;
  outA |= tmp;

  outB = pos.Y;
  outB &= RDP_POS_MASK;
  tmp = pos.X;
  tmp <<= 12;
  outB |= tmp;
}

macro writePointRect(vec16 p)
{
  vec16 posSize = 0;
  vec16 posStart = p;
  
  posStart.X = posStart.x;
  posStart.Y = posStart.y;
  posSize.X = 8;
  posSize.Y = 8;
  posSize += posStart;

  u32 rectStart, rectEnd;
  encodeRectPos(rectStart, rectEnd, posSize);

  //       Offset: |  0  |  1  |  2  |  3  ||  4  |  5  |  6  |  7  |
  //  "Fill Rect": |0x36 |   X1/Y1 (10.2)  ||  -  |  X0/Y0 (10.2)   |
  store(rectStart, dplDMEM, 4);
  @Barrier("cmd") store(rectEnd,   dplDMEM, 0);  
  @Barrier("cmd") store(CMD_FILL_RECT, dplDMEM, 0);
  dplDMEM += 8;
}

/**
 * RSPL relies on some vector registers setup by 'rsp_queue.inc' in libdragon.
 * Replicate the setup here for the two shift and zero register values.
 */
macro globalSetup()
{
  undef VSHIFT; undef VSHIFT8;
  vec16<$v30> VSHIFT; // make writable
  vec16<$v31> VSHIFT8;

  asm("vxor $v00, $v00, $v00");
  VSHIFT8 = load_vec_s8(ZERO);
  VSHIFT = VSHIFT8 >>> 8;
}

@NoReturn
function Main()
{
  RSPQ_Loop:

  globalSetup(); 
  const u8 CMD_SYNC_FULL  = 0x29;
  const u8 CMD_FILL_RECT  = 0x36;

  vec16 screenOffset = 0x200;
  vec16 screenScale = 4;

  // Load vertices
  u32 vertRDRAM = load(VERTEX_ADDR);
  u32 vertDMEM  = RSPQ_DMEM_BUFFER;
  u32 vertSize = 32;
  u32 vertDMEMEnd = vertDMEM + vertSize;

  dmaInAsync(vertRDRAM, vertDMEM, vertSize);

  u32 dplRDRAM     = load(RDPQ_CURRENT);
  u16 dplDMEM      = RSPQ_DMEM_BUFFER;
  u16 dplDMEMStart = RSPQ_DMEM_BUFFER;

  vec16 mat0 = load(MATRIX, 0x00).xyzwxyzw;
  vec16 mat1 = load(MATRIX, 0x08).xyzwxyzw;
  vec16 mat2 = load(MATRIX, 0x10).xyzwxyzw;

  dmaAwait();

  loop {
    vec16 pos = load(vertDMEM);
    //print(pos);

    // transform position, this is only rotation and scaling.
    // since the matrix is a 16bit fractional, we can also only scale down here
    VTEMP = mat0:sfract  * pos.xxxxXXXX;
    VTEMP = mat1:sfract +* pos.yyyyYYYY;
    pos   = mat2:sfract +* pos.zzzzZZZZ;

    pos *= screenScale;
    pos += screenOffset;
    
    writePointRect(pos);
    pos.xyzw = pos.XYZW;
    writePointRect(pos);

    vertDMEM += 16;
  } while(vertDMEM != vertDMEMEnd)

  // Sync full 
  store(CMD_SYNC_FULL, dplDMEM);
  dplDMEM += 8; 

  // DMA commands to RDRAM and store the total size for the CPU to fetch later
  u32 dmaSize = dplDMEM - dplDMEMStart;
  dmaOutAsync(dplRDRAM, dplDMEMStart, dmaSize);
  dmaAwait();

  dplRDRAM += dmaSize; 
  set_rdp_end(dplRDRAM);

  // RDPQ_Triangle_Send_Async();
  RDPQ_Triangle_Cull:

  asm("break"); // halts RSP
}

include "./rspq_triangle.inc"