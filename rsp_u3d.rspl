include "rsp.inc"

// some dummy defines to make it work without libdragon
#define RSPQ_BeginOverlayHeader ;
#define RSPQ_EndOverlayHeader ;
#define RSPQ_BeginSavedState ;
#define RSPQ_EndSavedState ;

state 
{
  u8 SHIFT_DATA[8];
  
  u32 VERTEX_ADDR;
  u32 VERTEX_ADDR_END;
  u32 RDPQ_CURRENT;
  
  alignas(8) u16 MATRIX[3][4]; // fractional matrix for scaling + rotation

  /**
   * 
   * Buffer format (RDPQ_Triangle compatible):
   * @TODO: remove clip pos
   * 
   *   Type |     Name  | Offset
   * -------+-----------+--------
   * s16[2] | Pos-XY    | 0x00
   * s16    | Depth     | 0x04
   * u8     | Clip-Code | 0x06
   * u8     | Rej. Code | 0x07
   * u8[4]  | Color     | 0x08
   * s16[2] | UV        | 0x0C
   * s16[3] | Clip-Pos  | 0x10  (t3d specific)
   * s16    | W         | 0x16
   * f16[3] | Clip-Pos  | 0x18  (t3d specific)
   * f16    | W         | 0x1E
   * s16.16 | InvW      | 0x20
   * -------+-----------+-0x24---
   */
  alignas(16) u8 TRI_BUFF[256];

  alignas(16) u8 RSPQ_DMEM_BUFFER[128];

  u16 TRI_CONST1[8];
  u8 VERT_BUFF[512];

  vec16 RSPQ_SCRATCH_MEM; 
}

// See rspq_triangle.inc
function RDPQ_Triangle(
  u32<$a0> triCmd, 
  u16<$a1> vtx1, u16<$a2> vtx2, u16<$a3> vtx3,
  u16<$v0> cull, u16<$s3> ptrDMEM
);

// DMA from RDRAM into DMEM
macro dmaInAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_read(size);
}

// DMA from DMEM into RDRAM
macro dmaOutAsync(u32 addrRDRAM, u32 addrDMEM, u32 size)
{
  @Barrier("DMA") set_dma_addr_rsp(addrDMEM);
  @Barrier("DMA") set_dma_addr_rdram(addrRDRAM);
  @Barrier("DMA") set_dma_write(size);
}

/**
 * RSPL relies on some vector registers setup by 'rsp_queue.inc' in libdragon.
 * Replicate the setup here for the two shift and zero register values.
 */
macro globalSetup()
{
  undef VSHIFT; undef VSHIFT8;
  vec16<$v30> VSHIFT; // make writable
  vec16<$v31> VSHIFT8;

  asm("vxor $v00, $v00, $v00");
  VSHIFT8 = load_vec_s8(ZERO);
  VSHIFT = VSHIFT8 >>> 8;

  // @TODO:
  u16 a = 0xFFFF;
  vec16 b = 0x200;
  u32 addr = TRI_CONST1;
  @Barrier("const") store(VZERO, addr);
  @Barrier("const") store(a, addr);
  @Barrier("const") store(b.xyzw, addr, 8);
}

@NoReturn
function Main()
{
  globalSetup();

  // Note: those registers will survive the entire loop and a RDPQ_Triangle_Send_Async call
  u32<$s6> vertRDRAM = load(VERTEX_ADDR);
  u32<$s5> vertRDRAMEnd = load(VERTEX_ADDR_END);
  u32<$s4> dplRDRAM = load(RDPQ_CURRENT);

  // man loop that will load in vertices, converts them to RDP commands
  // and writes them out for the RDP.
  MAIN_LOOP:
  // print(vertRDRAM, vertRDRAMEnd);

  // Load vertices
  u32 vertDMEM  = RSPQ_DMEM_BUFFER;
  u32 vertSize = 24;
 
  dmaInAsync(vertRDRAM, vertDMEM, vertSize);
  vertRDRAM += vertSize; 

  u32 vertDMEMEnd = vertDMEM + vertSize;
  vec16 screenOffset = 0x200;
 
  u16<$s3> dplDMEM = RSPQ_DMEM_BUFFER;
  
  vec16 mat0 = load(ZERO, 24).xyzwxyzw;
  vec16 mat1 = load(ZERO, 32).xyzwxyzw;   
  vec16 mat2 = load(ZERO, 40).xyzwxyzw; 

  u16<$a1> vtx1 = TRI_BUFF;
  u16<$a2> vtx2 = vtx1 + 64;
  u16<$a3> vtx3;

  loop { 
    RA = get_dma_busy();
    vtx3 = vtx2 + 64; // fill delay slot
  } while(RA != 0)

  loop {
    vec16 pos = load_vec_s8(vertDMEM);
    
    // transform position, this is only rotation and scaling.
    // since the matrix is a 16bit fractional, we can also only scale down here
    VTEMP = mat0:sfract  * pos.xxxxXXXX; 
    VTEMP = mat1:sfract +* pos.yyyyYYYY; 
    pos   = mat2:sfract +* pos.zzzzZZZZ;

    vec16 col = pos.Z;
    col:sfract *= col:sfract;

    pos >>= 6;
    pos += screenOffset;
    
    @Barrier("attr") store(pos.xyzw, vtx1, 0); 
    @Barrier("attr") store_vec_u8(col.X, vtx1, 8);
    vtx1 += 64;
    vertDMEM += 8; 
  } while(vertDMEM != vertDMEMEnd)

  vtx1 = TRI_BUFF;
  
  u32<$a0> triCmd = 0xCF00;
  u16<$v0> cull = 1; 
  
  RDPQ_Triangle(triCmd, vtx1, vtx2, vtx3, cull, dplDMEM);
  RDPQ_Triangle_Skip:
  
  u16 dplDMEMStart = RSPQ_DMEM_BUFFER;

  if(vertRDRAM == vertRDRAMEnd) 
  {
    const u8 CMD_SYNC_FULL = 0x29;    
    store(CMD_SYNC_FULL, dplDMEM);
    dplDMEM += 8;
  }

  u16 dmaSize = dplDMEM - dplDMEMStart; 
  if(dplDMEM != dplDMEMStart) 
  {
    dmaOutAsync(dplRDRAM, dplDMEMStart, dmaSize);
    dplRDRAM += dmaSize; 
     
    loop { 
      RA = get_dma_busy();
      // @TODO: fill delay slot here
    } while(RA != 0)
  }
  
  set_rdp_end(dplRDRAM);
  if(vertRDRAM != vertRDRAMEnd) {
    goto MAIN_LOOP;
  }

  asm("break"); // halts RSP
} 

include "./rspq_triangle.inc"
